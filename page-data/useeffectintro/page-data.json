{"componentChunkName":"component---src-templates-post-tsx","path":"/useeffectintro/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu"}},"markdownRemark":{"id":"840e9b57-2a64-5dcc-8c74-c067ee80d54f","excerpt":"先是在前端社群上看到有人在問問題，為什麼他在開發時，，callback 會執行兩次，才看到有人貼上 React 18 beta 的文件，裡面提到為什麼 React 18 會修改成在嚴格模式下執行兩次。 但我看到其中有篇標題  最吸引我，文章很長很長，官方直接給了滿多正確使用 useEffect…","html":"<p>先是在前端社群上看到有人在問問題，為什麼他在開發時，<code class=\"language-text\">useEffect(callback,[])</code>，callback 會執行兩次，才看到有人貼上 React 18 beta 的文件，裡面提到為什麼 React 18 會修改成在嚴格模式下執行兩次。</p>\n<p>但我看到其中有篇標題 <code class=\"language-text\">You Might Not Need an Effect</code> 最吸引我，文章很長很長，官方直接給了滿多正確使用 useEffect 的情境時機，甚至包含使用 guidance 指引。</p>\n<p>所以就想寫一篇文章，先從 React 18 useEffect 兩次 callback 帶來什麼影響，後面再來介紹 You Might Not Need an Effect 寫了些什麼吧。</p>\n<p>React 18 beta document: <a href=\"https://beta.reactjs.org/learn/you-might-not-need-an-effect\" title=\"You Might Not Need an Effect\">You Might Not Need an Effect</a></p>\n<h2 id=\"what-is-useeffect\" style=\"position:relative;\"><a href=\"#what-is-useeffect\" aria-label=\"what is useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is useEffect</h2>\n<p>文件上對於 useEffect 定義是 <code class=\"language-text\">The Effect Hook lets you perform side effects in function components</code>，顧名思義就是 function component 的 side effect，我自己也偏向這個說法，拋棄掉過去的 componentDidMount 等等的 lifecycle 的想法。</p>\n<p>useEffect 使用上就三個參數，依照下方介紹分為 callback 跟 cleanCallback 以及 dependency array。</p>\n<ul>\n<li>useEffect 參數</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(\n  callback();\n  return () => cleanCallback();\n,[arg1, ....])\n// dependency array, dependency array is depending on shallow equal compare</code></pre></div>\n<ul>\n<li>useEffect 執行順序</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">* React mounts the component.\n    * Effect effects are created\n* React update the component. if arg1 compared the previous is true.\n    * Effect cleanCallback code runs and callback runs.\n* React unmounts the component.\n    * Effect cleanCallback code runs.</code></pre></div>\n<h2 id=\"react-18-simulates-useeffect\" style=\"position:relative;\"><a href=\"#react-18-simulates-useeffect\" aria-label=\"react 18 simulates useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 18 simulates useEffect</h2>\n<p>順道提一開始的問題，為什麼 useEffect 會執行兩次吧，下方是 React useEffect 在 React 18 strict mode 下，useEffect 是如何被調用的。</p>\n<ul>\n<li>Component render step on strict mode react 18</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">* React mounts the component.\n    * Effect effects are created.\n* React simulates effects being destroyed on a mounted component.\n    * Effects are destroyed.\n* React simulates effects being re-created on a mounted component.\n    * Effect setup code runs</code></pre></div>\n<p>這個 flow 只會在 development 下開啟 strict mode 執行，react 希望透過快速的執行 useEffect cleanup，並且 重新使用新的 state，這是為了確保我們有正確的回收 component useEffect，</p>\n<p>React Document: <a href=\"https://reactjs.org/docs/strict-mode.html#ensuring-reusable-state\" title=\"ensuring-reusable-state\">ensuring-reusable-state</a></p>\n<p>React github issue: <a href=\"https://github.com/facebook/react/issues/24502#issuecomment-1118867879\" title=\"dan abramov reply\">dan abramov reply</a></p>\n<p>Demo codesandbox: <a href=\"https://codesandbox.io/s/long-snowflake-t4jn2w?file=/src/EffectTest.js\" title=\"useEffect on react 17\">useEffect on react 17</a> 、 <a href=\"https://codesandbox.io/s/suspicious-beaver-2wewyc?file=/src/EffectTest.js\" title=\"useEffect on react 18\">useEffect on react 18</a></p>\n<h2 id=\"how-to-solve-the-twice-callback-problem\" style=\"position:relative;\"><a href=\"#how-to-solve-the-twice-callback-problem\" aria-label=\"how to solve the twice callback problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>how to solve the twice callback problem</h2>\n<p>如果你不想關閉 strict mode 的話，又想避免 callback 被調用兩次的話，答案是無解…。</p>\n<p>如果你在 useEffect fetch api 的話，只能依賴 變數 去做為 setState 的 throttle，避免顯示 setState on unmounted 下方的錯誤。或用其他 state manager 去存取資料，更或是用 AbortController 去回收 api request。</p>\n<ul>\n<li>unmounted and stop setState</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() => {\n  let stop = false;\n  fetch(url).then(res => {\n    if (!stop) {\n      setList(res);\n    }\n  })\n  return () => { stop = true }\n}, []);</code></pre></div>\n<p>但我個人是認為，我自己是會視而不見，因為在開發時，就應該完全清楚知道整個的 data flow、component unmounted 的時機點，以及 state 是會在什麼時機被回收的。開發上要注意重複 callback 會不會有問題即可。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"margin: 2vw 0;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1504px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6951966e612deb0810354a1ad6549cff/bf02b/setstate_error.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.68686868686869%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAABYlAAAWJQFJUiTwAAAApUlEQVQY052N2wqCQBRF5/9/TEUMBPOCBZVj5ly1UfGSc2LUosdqsx7WPrA56HDMi9P5esmKDN8yrKRsZNUwrhhXXKhVKFvqchGy4kIyXlc1At8HzwPHMVjWbNuT60673bwPdZLoKDIEgU5TU8NIp2kTJyqOJ0oRtC0QAhhDngMhD0rvZdkKMXcdjCMMg2GTfqsrfY/g9+iXLGOtP9GrfJF/Pr/HT0v3WT7QaGyJAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/6951966e612deb0810354a1ad6549cff/a805d/setstate_error.webp 495w,\n/static/6951966e612deb0810354a1ad6549cff/36741/setstate_error.webp 990w,\n/static/6951966e612deb0810354a1ad6549cff/51813/setstate_error.webp 1504w\"\n              sizes=\"(max-width: 1504px) 100vw, 1504px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/6951966e612deb0810354a1ad6549cff/b3db0/setstate_error.png 495w,\n/static/6951966e612deb0810354a1ad6549cff/8ddfd/setstate_error.png 990w,\n/static/6951966e612deb0810354a1ad6549cff/bf02b/setstate_error.png 1504w\"\n            sizes=\"(max-width: 1504px) 100vw, 1504px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/6951966e612deb0810354a1ad6549cff/bf02b/setstate_error.png\"\n            alt=\"setstate error\"\n            title=\"setstate error\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">setstate error</figcaption>\n  </figure></p>\n<h2 id=\"when-we-should-use-useeffect\" style=\"position:relative;\"><a href=\"#when-we-should-use-useeffect\" aria-label=\"when we should use useeffect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When we should use useEffect</h2>\n<p>回到一開始的重點，根據 <a href=\"https://beta.reactjs.org/learn/you-might-not-need-an-effect\" title=\"You Might Not Need an Effect\">You Might Not Need an Effect</a> 的文件介紹，下面是結論，關於判斷何時該使用 useEffect 的結論。</p>\n<ul>\n<li>you-might-not-need-an-effect recaps (中文是我翻譯的，很直翻…)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- If you can calculate something during render, you don’t need an Effect.\n( 如果你可以在 render 時，計算出某些值，那你不需要 Effect。 )\n\n- To cache expensive calculations, add useMemo instead of useEffect.\n( 當你需要快取耗費效能的計算，請使用 useMemo 而不是 useEffect )\n\n- To reset the state of an entire component tree, pass a different key to it.\n( 要重置這個 component tree 中的 state，傳遞 key 到 component 來達到 )\n\n- To reset a particular bit of state in response to a prop change, set it during rendering.\n( 要重置特定的 prop 改變來自 response 特定的 state，那就設定這個 state 在 rendering 時。 )\n\n- Code that needs to run because a component was displayed should be in Effects, the rest should be in events.\n( code 需要執行，是因為來自顯示時的副作用，那會需要用 Effect，其餘都會是在 event。 )\n\n- If you need to update the state of several components, it’s better to do it during a single event.\n( 如果需要更新 state 是在各個不同的 components 時，比較好的做法是在單一 event 處理 )\n\n- Whenever you try to synchronize state variables in different components, consider lifting state up.\n( 不論你是不是要嘗試在不同 components 同步 state，考慮把 state 拉到上層。 )\n\n- You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.\n( 你可以使用 useEffect fetch 資料，但你需要處理回收邏輯，來避免 race condition。 )</code></pre></div>\n<p>我自己收斂的結論是，頁面的 render event 皆用 useEffect，類似 <code class=\"language-text\">ga track</code>、 <code class=\"language-text\">websocket</code>，剩下就盡量使用 event 處理，當你發現 event 不符合 DRY 邏輯，可能就是要搬移到 useEffect。</p>\n<p>文中很多在強調請先不要用 useEffect、不過度優化效能，真的有出現問題才回頭考慮用 useEffect。</p>\n<ul>\n<li>unnecessary Effect</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Form() {\n  const [firstName, setFirstName] = useState('Taylor');\n  const [lastName, setLastName] = useState('Swift');\n\n  // Avoid: redundant state and unnecessary Effect\n  const [fullName, setFullName] = useState('');\n  useEffect(() => {\n    setFullName(firstName + ' ' + lastName);\n  }, [firstName, lastName]);\n  // ...\n}</code></pre></div>\n<h2 id=\"use-case-typing-search-input\" style=\"position:relative;\"><a href=\"#use-case-typing-search-input\" aria-label=\"use case typing search input permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Use case: typing search input</h2>\n<p>內文我覺得最棒的例子，是一個關於 <code class=\"language-text\">page</code>、<code class=\"language-text\">search</code> 的更新，我們直接看 sample code 比較快。</p>\n<ul>\n<li>useEffect handle page and query</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  const [page, setPage] = useState(1);\n\n  useEffect(() => {\n    let ignore = false;\n    fetchResults(query, page).then(json => {\n      if (!ignore) {\n        setResults(json);\n      }\n    });\n    return () => {\n      ignore = true;\n    };\n  }, [query, page]);\n\n  function handleNextPageClick() {\n    setPage(page + 1);\n  }\n  // ...\n}</code></pre></div>\n<p>假設你只用 event 處理更新列表的話，你在 載入頁面、上一頁、下一頁，一樣也要用 useEffect 處理 fetch 資料，還可以在這邊針對每次的 fetch response callback 做控制。</p>\n<p>為什麼我們會需要 ignore 來判斷 setResult，這是因為有可能會出現 race condition 的問題，當你今天連續的更新 query，</p>\n<p>假設 query 可以透過 input 更新，當快速的輸入 input，就會觸發多次 fetch，假設今天前面的請求比後面還慢，那就代表我們 前面的 setState 執行會慢於後面的，就導致資料對不上當前 input 的 query。</p>\n<p>這情境用 useEffect 會明顯好閱讀許多，集中管理資料的進入點。雖然你硬要用 onClick 處理也不是不行，就是散落邏輯不容易維運。</p>\n<ul>\n<li>race condition ( if user want to query apple )</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. typing `app`.\n2. fetch api with `app` and waiting api response.\n3. continue typing `apple`.\n4. fetch api with `apple` and waiting api response.Somehow fetch api `apple` response faster than before.\n6. setState as `apple` response.\n7. fetch api `app` response.\n8. setState as app response.</code></pre></div>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<p>開發時不要預想用 useEffect 處理，但如果 code 難以閱讀、管理，或是要避免每次 update 都執行的 function，那才來考慮使用 useEffect，如果還是聽不懂我在說啥毀，可以回上面的 <a href=\"/useeffectintro/#when-we-should-use-useeffect\" title=\"recap\">recap</a> 再看一遍，又或是把 React 18 的文章看一看吧。</p>\n<h2 id=\"心得\" style=\"position:relative;\"><a href=\"#%E5%BF%83%E5%BE%97\" aria-label=\"心得 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>心得</h2>\n<p>我自己看完整篇 React 18，是真心覺得真的很棒，推薦大家都要看一下，連面試時候我都跟面試者推薦看一下，因為內容真的太棒了。雖然滿多觀念你可能都知道，但如果能多少學到一點點東西，我覺得都算超值了。</p>\n<p>公司有一個專案，算是沒有好好的使用 useEffect，導致 useEffect 之間，互相 depenency，一個不注意就會長這樣，所以我算是對 useEffect 感觸許多。<del>恩…，見賢思齊，見不賢而內自省也</del>。</p>\n<p>過去 React 都是給我們很多工具，但很少會跳出來說，怎樣寫得完美準則，這點也符合我喜歡 React 的原因，大家常形容<code class=\"language-text\">寫 React 就像是在大海游泳，沒有給你很明確的方向，可以寫出糞 code，但同時又可以寫出很優美的 code</code>，完全看你對 React 的熟悉掌握度如何。</p>\n<p>ps. 稍微 murmur 一下，文章兩個重點，反倒讓我極度難收斂…，很久沒打文章，表達能力真的變差了，還是看不懂我在說啥的，就直接看 React 18 文章吧 XDD。</p>\n<p>React 18 beta document: <a href=\"https://beta.reactjs.org/learn/you-might-not-need-an-effect\" title=\"You Might Not Need an Effect\">You Might Not Need an Effect</a></p>","fields":{"readingTime":{"text":"10 min read"}},"frontmatter":{"title":"Rediscover useEffect and when to use it","date":"August 06, 2022","description":"開發時不要預想用 useEffect 處理，但如果 code 難以閱讀、管理，或是要避免每次 update 都執行的 function，那才來考慮使用 useEffect。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#c8c8c8","images":{"fallback":{"src":"/static/c94152458d98aee0f7484f9874cffe9a/36f66/sideeffect.jpg","srcSet":"/static/c94152458d98aee0f7484f9874cffe9a/460bb/sideeffect.jpg 300w,\n/static/c94152458d98aee0f7484f9874cffe9a/8dc98/sideeffect.jpg 600w,\n/static/c94152458d98aee0f7484f9874cffe9a/36f66/sideeffect.jpg 1200w","sizes":"(min-width: 1200px) 1200px, 100vw"},"sources":[{"srcSet":"/static/c94152458d98aee0f7484f9874cffe9a/b979a/sideeffect.webp 300w,\n/static/c94152458d98aee0f7484f9874cffe9a/2fa07/sideeffect.webp 600w,\n/static/c94152458d98aee0f7484f9874cffe9a/f9756/sideeffect.webp 1200w","type":"image/webp","sizes":"(min-width: 1200px) 1200px, 100vw"}]},"width":1280,"height":640}}},"image":{"publicURL":"/static/c94152458d98aee0f7484f9874cffe9a/sideeffect.png"}}},"previous":{"fields":{"slug":"/2021-05-cssanimation/"},"frontmatter":{"title":"CSS animation Performance"}},"next":null},"pageContext":{"id":"840e9b57-2a64-5dcc-8c74-c067ee80d54f","previousPostId":"e20c6779-3974-5700-9211-6a3f4a1f0139","nextPostId":null}},"staticQueryHashes":["3649515864","3761976949","441988385"]}