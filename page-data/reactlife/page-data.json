{"componentChunkName":"component---src-templates-blog-post-js","path":"/reactlife/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"f798b61f-9b32-56c3-914d-af6e90ce931e","fields":{"slug":"/2018-07-reactlife/"},"headings":[{"value":"React Life Cycle","id":"react-life-cycle","depth":2},{"value":"Mounting","id":"mounting","depth":2},{"value":"constructor() :","id":"constructor-","depth":4},{"value":"componentWillMount() -> 17 版將丟棄 :","id":"componentwillmount---17-版將丟棄-","depth":4},{"value":"get­Derived­State­From­Props(nextProps, prevState) -> 新增","id":"get­derived­state­from­propsnextprops-prevstate---新增","depth":4},{"value":"render()","id":"render","depth":4},{"value":"componentDidMount()","id":"componentdidmount","depth":4},{"value":"componentWillReceiveProps(nextProps) -> 17 版將丟棄","id":"componentwillreceivepropsnextprops---17-版將丟棄","depth":4},{"value":"static getDerivedStateFromProps(nextProps, prevState) -> 新增","id":"static-getderivedstatefrompropsnextprops-prevstate---新增","depth":4},{"value":"shouldComponentUpdate(nextProps, nextState)：","id":"shouldcomponentupdatenextprops-nextstate：","depth":4},{"value":"componentWillUpdate（nextProps, nextState) -> 17 版將丟棄","id":"componentwillupdate（nextprops-nextstate---17-版將丟棄","depth":4},{"value":"render","id":"render-1","depth":3},{"value":"getSnapshotBeforeUpdate(prevProps, prevState) -> 新增","id":"getsnapshotbeforeupdateprevprops-prevstate---新增","depth":3},{"value":"componentDidUpdate(prevProps, prevState, snapshot)","id":"componentdidupdateprevprops-prevstate-snapshot","depth":4},{"value":"componentWillUnmount()","id":"componentwillunmount","depth":4},{"value":"元件渲染順序","id":"元件渲染順序","depth":2}],"excerpt":"如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle…","html":"<p>如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle，順便了解新版本多的功能，還有未來會移除的功能。</p>\n<!--- ![react lifecycle](../images/react.png \"react lifecycle\") --->\n<h2 id=\"react-life-cycle\" style=\"position:relative;\"><a href=\"#react-life-cycle\" aria-label=\"react life cycle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React Life Cycle</h2>\n<p>大致上可分類為 Mounting 增加、Updating 更新、Unmounting 移除增加。</p>\n<p>\n  <figure class=\"gatsby-resp-image-figure\" style=\"margin: 7vw 0;\">\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 61.21212121212122%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsSAAALEgHS3X78AAABtklEQVQoz52S2W7jMAxF+/8f10GbOouTeFG8S7IWavOa0mnaQedxCEgQCB7iXlIv9++Y59k5C6BDCOM4ujBQSrMsq5tW6y05DAM8At/ruiLy8gP7EIqiOsUXxnusBq2VUkmSdJRa64wBIUSe55jp+36ap1+wsSEmYhfXpN1KGaOIi54rKbq2UVJiR2tRGhhjpukBowBsiWq1CZfKnAtIG3fK2P5Sx4QllSSdO5dAeyxBKVpKifwTRnuHwzG5JqiNC80FSGUaKqJru0/a6NqVVAsJ6uFDA2CDvzCeZVnwts43VNVUMWEbbo5EHk71Me1L5hq28XqL3zCS23iHQYHLWyAt3Ji7dXDJClLRvGKk5qQRXD4GqND7Zv4J4wLqumnqxns3Bhs8zGMYvVjsGbr3vnyV9dukD6Njzg9hCN57RHCvXwNbOOe9UMvkVk8Wny8uV20E9BTkdYL0Ppb3QOZBLetjK+sdZ/zldJNNclIWlQvmmH3s4te0OmsQBUtPJNrFf/bJe8FT43XFqiiJPq67W0ee8M+ece/KKKmlsWbC3zY4bfWWAWW8GafReitBKJDGmX9/2H/EJ4mWqKuQAPCAAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <picture>\n        <source\n          srcset=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/a805d/react-life.webp 495w,\n/static/56e1ae1a077d66ecc3899de3eec3e5d6/6ec60/react-life.webp 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/b3db0/react-life.png 495w,\n/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n          src=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png\"\n          alt=\"react lifecycle\"\n          title=\"react lifecycle\"\n          src=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png\"\n        />\n      </picture>\n      </span>\n  </span>\n  \n  <figcaption class=\"gatsby-resp-image-figcaption\">react lifecycle</figcaption>\n  </figure>\n      <br>\n大推 Dan Abramov 的圖表， <a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" title=\"React Life Cycle\">網站版 React Life Cycle 網友製</a></p>\n<p>PS.React 官方已經在 2018/03/27 宣告 不推薦使用:<br>\ncomponentWillMount、componentWillReceiveProps、componentWillUpdate 並且 react 16.3 版本以後這些 method 會加上前綴 UNSAFE_，17 版本會丟棄。提醒使用的時候要特別小心。</p>\n<p>另外在看下面的時候可以搭配使用 <a href=\"https://codesandbox.io/s/xp7lk14x4w\" title=\"React Life Cycle\">react life Cycle sample</a>，點開 console.log 查看執行順序，裡面操作主要兩個，一個是父元件更新傳遞的 props，還有元件自己 setState。</p>\n<h2 id=\"mounting\" style=\"position:relative;\"><a href=\"#mounting\" aria-label=\"mounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting</h2>\n<p>Mounting 會在元件被建立時被執行。</p>\n<h4 id=\"constructor-\" style=\"position:relative;\"><a href=\"#constructor-\" aria-label=\"constructor  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor() :</h4>\n<p>這是 es6 的 class 語法糖，可以說是建構並初始化物件，這邊會繼承 React.Component，假設你元件要使用到 props，就必須這樣寫 super(props)來繼承父類別。這階段簡單說就是開始建立這個物件。如果你沒有要定義 state、或是在這邊綁定 method (另可以選用 arrow function 綁定 method)，就不需要用到 constructor。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// get parents props\nconstructor(props) {\n  super(props);\n}</code>\n        </deckgo-highlight-code>\n<h4 id=\"componentwillmount---17-版將丟棄-\" style=\"position:relative;\"><a href=\"#componentwillmount---17-%E7%89%88%E5%B0%87%E4%B8%9F%E6%A3%84-\" aria-label=\"componentwillmount   17 版將丟棄  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillMount() -> 17 版將丟棄 :</h4>\n<p>緊接在 constructor 後執行 componentWillMount，提醒只會在初始執行一次，移除後重新建立元件也不會在執行 componentWillMount。另外是唯一會在 server side render 時執行的 life Cycle method，關於 WillMount 最多的討論就是，在這邊擺放 fetch api 是否正確。</p>\n<p>官方表示，因為 server side 會執行一次，client side 也會再多執行一次，造成重複要資料動作。另外在這邊做 async api 處理，是無法暫停 render 動作，你一樣要等 render 完成後，你還是必須等待類似 loading 空畫面跑出來，才能在更新畫面，所以會更推薦在 componentDidMount 做 fetch api。</p>\n<h4 id=\"get­derived­state­from­propsnextprops-prevstate---新增\" style=\"position:relative;\"><a href=\"#get%C2%ADderived%C2%ADstate%C2%ADfrom%C2%ADpropsnextprops-prevstate---%E6%96%B0%E5%A2%9E\" aria-label=\"get­derived­state­from­propsnextprops prevstate   新增 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>get­Derived­State­From­Props(nextProps, prevState) -> 新增</h4>\n<p>get­Derived­State­From­Props 主要是對比到 componentWillReceiveProps，get­Derived­State­From­Props 帶有兩個參數 nextProps, prevState，更新後的 props，先前的 state，這個 method 會在初始 render 調用，還有父元件重新 render，也會調用到。</p>\n<p>還有當你使用了 get­Derived­State­From­Props，要更新 state 就需要回傳物件，如果不更新就必須回傳 null。</p>\n<p>PS.當你使用 get­Derived­State­From­Props，也同時使用 componentWillMount，WillMount 會不執行，並且 console 會傳出警告，另外就算改用 UNSAFE_componentWillMount 也不會執行。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">class ExampleComponent extends React.Component {\n  // Initialize state in constructor,\n  state = {\n    isScrollingDown: false,\n    lastRow: null,\n  };\n  // means you can not use &quot;this.setState&quot;\n  // return will update state\n  static getDerivedStateFromProps(props, state) {\n    if (props.currentRow !== state.lastRow) {\n      return {\n        isScrollingDown: props.currentRow &gt; state.lastRow,\n        lastRow: props.currentRow,\n      };\n    }\n    // Return null to indicate no change to state.\n    return null;\n  }\n}\nby officical react</code>\n        </deckgo-highlight-code>\n<p>官方介紹使用情境: <a href=\"https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\" title=\"get­Derived­State­From­Props example\">get­Derived­State­From­Props example</a></p>\n<p>移動到 Update 部分: <a href=\"#static-getDerivedStateFromProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4 id=\"render\" style=\"position:relative;\"><a href=\"#render\" aria-label=\"render permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>render()</h4>\n<p>執行 setState、更新父元件傳遞的 props，都會執行 render()，假設 shouldComponentUpdate()回傳 false，則是阻止 render 執行。使用 render 必須回傳 react element(JSX、createClass、react 元件)、或 Fragment、Portals(可以綁定 render 到其他 Dom root)、如果不回傳內容則回傳 boolean、或是 null。</p>\n<p><a href=\"https://reactjs.org/docs/portals.html\" title=\"Portals\">Portals</a></p>\n<p>然後使用 render 盡量保持 pure，例如盡量少在這邊額外處理 props 以及 state，在外面處理保持 render 內乾淨。(這點我也沒做到…)</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">class App extends React.Component {\n  filterProps = () =&gt; {\n    const { personList } = this.props\n    return (\n      {personList.filter(elem =&gt; elem.age &gt; 20)}\n    )\n  }\n  render() {\n    return (\n      &lt;div&gt;\n        older than 20 years:\n        {this.filterProps()}\n      &lt;/div&gt;\n    )\n  }\n}</code>\n        </deckgo-highlight-code>\n<h4 id=\"componentdidmount\" style=\"position:relative;\"><a href=\"#componentdidmount\" aria-label=\"componentdidmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidMount()</h4>\n<p>componentDidMount 會在 render 執行完成後調用。這應該是最多人用到的生命週期，舉凡綁定 DOM 事件，執行 ajax，多半會在這邊使用。提醒在這邊使用 setState 會迫使 render 執行兩次，盡量在 constructor 內設定好初始 state，避免過多 render 執行。</p>\n<p>另外提醒在這邊綁定 DOM eventListener，記得在 willUnMount 取消綁定 EventListener，如果重新 render 元件會再次執行 DidMount，造成過多的綁定事件。</p>\n<br/>\n## Updating\n主要是在父元件更新傳遞的props，或是元件中使用到setState，會開始整個Update的生命週期。另外setState({xxxx},callback)，則是會在整個週期執行完成才會執行callback。\n<h4 id=\"componentwillreceivepropsnextprops---17-版將丟棄\" style=\"position:relative;\"><a href=\"#componentwillreceivepropsnextprops---17-%E7%89%88%E5%B0%87%E4%B8%9F%E6%A3%84\" aria-label=\"componentwillreceivepropsnextprops   17 版將丟棄 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillReceiveProps(nextProps) -> 17 版將丟棄</h4>\n<p>componentWillReceiveProps(nextProps)，會回傳更新過的 props，並且可以使用 setState 來更新 state，提醒在這邊使用 setstate，並不會驅使重跑 componentWillReceiveProps，因為 ReceiveProps 只會在更新傳遞的 props 時被調用。</p>\n<p>react 官方是創建 get­Derived­State­From­Prop 來替代掉 WillReceiveProps，主要明顯差異在於 get­Derived­State­From­Prop 必須使用 static，且會在 Mounting 階段執行，\b\b\b 但是會自動傳遞更新 state，而 componentWillReceiveProps 則是純粹執行，\b 不依靠 return 更新。</p>\n<h4 id=\"static-getderivedstatefrompropsnextprops-prevstate---新增\" style=\"position:relative;\"><a href=\"#static-getderivedstatefrompropsnextprops-prevstate---%E6%96%B0%E5%A2%9E\" aria-label=\"static getderivedstatefrompropsnextprops prevstate   新增 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>static getDerivedStateFromProps(nextProps, prevState) -> 新增</h4>\n<p>Updating 階段中，getDerivedStateFromProps 則是在父元件更新傳遞的 props 時調用，提醒一下這時候 this.props state 還會是未更新的。</p>\n<p>移動到 Mounting 部分: <a href=\"#get%C2%ADDerived%C2%ADState%C2%ADFrom%C2%ADProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4 id=\"shouldcomponentupdatenextprops-nextstate：\" style=\"position:relative;\"><a href=\"#shouldcomponentupdatenextprops-nextstate%EF%BC%9A\" aria-label=\"shouldcomponentupdatenextprops nextstate： permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>shouldComponentUpdate(nextProps, nextState)：</h4>\n<p>執行 receive props 後調用，這時候 this.props state 還會是未更新的。主要是判斷元件是否要往下繼續執行 willUpdate、render、componentDidUpdate，如果回傳 false，則會中斷整個更新循環，回傳 true 則是繼續往下執行，默認值為 true。</p>\n<p>一般會使用 shouldComponentUpdate 來優化效能，避免執行沒必要的 render。</p>\n<h4 id=\"componentwillupdate（nextprops-nextstate---17-版將丟棄\" style=\"position:relative;\"><a href=\"#componentwillupdate%EF%BC%88nextprops-nextstate---17-%E7%89%88%E5%B0%87%E4%B8%9F%E6%A3%84\" aria-label=\"componentwillupdate（nextprops nextstate   17 版將丟棄 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillUpdate（nextProps, nextState) -> 17 版將丟棄</h4>\n<p>Update 到 render 前最後一個，\b 提醒在這邊使用 setState 的話，會導致重跑回 update 的生命週期，然後在跑到 componentWillUpdate，若沒有設定好判斷，就會再 setState，再重跑回一遍，變成反覆 infinite 執行。</p>\n<h3 id=\"render-1\" style=\"position:relative;\"><a href=\"#render-1\" aria-label=\"render 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>render</h3>\n<p>Update 階段中開始處理 react 的畫面架構。提醒在這邊 setState 也同樣會重跑 Update，也同樣不建議在這邊執行 setState，容易產生無限迴圈。</p>\n<p>其餘跟 Mounting 階段一樣，回傳 react element，或是 react 相關的物件。</p>\n<h3 id=\"getsnapshotbeforeupdateprevprops-prevstate---新增\" style=\"position:relative;\"><a href=\"#getsnapshotbeforeupdateprevprops-prevstate---%E6%96%B0%E5%A2%9E\" aria-label=\"getsnapshotbeforeupdateprevprops prevstate   新增 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>getSnapshotBeforeUpdate(prevProps, prevState) -> 新增</h3>\n<p>能夠抓取 render 到執行渲染畫面更新前，所保持的畫面狀態，然後再傳第一個新值給 componentDidUpdate 當參數使用。</p>\n<h4 id=\"componentdidupdateprevprops-prevstate-snapshot\" style=\"position:relative;\"><a href=\"#componentdidupdateprevprops-prevstate-snapshot\" aria-label=\"componentdidupdateprevprops prevstate snapshot permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidUpdate(prevProps, prevState, snapshot)</h4>\n<p>Updating 階段最後一個執行，在畫面渲染更新後調用，新版本的還多加 getSnapshotBeforeUpdate 傳遞的參數。</p>\n<p>在這邊可以處理 call api 動作，或是 setState，促使重新更新，但提醒記得要判斷執行時機，否則一樣會進入無限迴圈。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">componentDidUpdate(prevProps) {\n    if (this.props.name !== prevProps.name) {\n        updateUser(this.props.id);\n    }\n}</code>\n        </deckgo-highlight-code>\n<br/>\n## Unmounting\n移除的時候會執行這個生命週期\n<h4 id=\"componentwillunmount\" style=\"position:relative;\"><a href=\"#componentwillunmount\" aria-label=\"componentwillunmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillUnmount()</h4>\n<p>元件要被移除的時候會執行，可以做清除綁定 eventlistener，或是清除 cookie、local storage 等等，提醒在這邊 setState 是不會重新執行 render。</p>\n<p>以上就是關於 react 新版的生命週期，看過一遍後更能理解，在哪個階段做什麼處理會更適合。</p>\n<h2 id=\"元件渲染順序\" style=\"position:relative;\"><a href=\"#%E5%85%83%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%A0%86%E5%BA%8F\" aria-label=\"元件渲染順序 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>元件渲染順序</h2>\n<p>大型開發滿常遇到這個問題，子元件先執行 render 還是父元件先，還有 lifeCycle 在父子元件的調用順序。稍微試跑了一下流程。<br>\n請查看 console <a href=\"https://codesandbox.io/s/5kpvvkqx7k\" title=\"react life Cycle parents child order\">react life Cycle parents child order</a></p>\n<ul>\n<li>Mounting\b: 簡單講就是父元件先執行到 render 後，再來開始執行子元件的 Mounting 生命週期，最後執行完子元件的 componentDidMount 後，再回頭執行父元件的 componentDidMount。</li>\n<li>Updating: 父元件執行到 render 後，換子元件執行直到 getSnapshotBeforeUpdate()，會再回父元件執行 getSnapshotBeforeUpdate()，然後再執行子元件的 componentDidUpdate，再回父元件執行 componentDidUpdate。</li>\n<li>UnMounting: 父元件先執行 componentWillUnmount，再來是子元件執行。</li>\n</ul>\n<p>以上就是關於 react 的新版生命週期，還有父子元件執行的順序。實際研究才發現各階段德每個 method 有許多細節，例如說 mounting 階段，componentWillMount 執行 fetch api，因為他只會在第一次 Mounting 被調用的特性，如果是抓取後續不會更新的資料，其實也是一種選擇，但今天如果你後面還可能會再次 call api，或許 componentDidMount 會更適合使用。</p>\n<p>—以上如果有錯誤，歡迎留言。感謝!—</p>","frontmatter":{"title":"React Life Cycle 生命週期更新版，父子元件執行順序","date":"July 27, 2018","description":"開發上用到React，而其中最重要的莫過於是生命週期lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新props觸發處理事件等等。接下來介紹一下新版本的life Cycle。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABPUlEQVQoz2OQxwRycvJy8gpKSrKSErJSkgrKKnKyMvLYAAO6gIICUKlBWKJpZoWGnbOOV5B5bq2WkyfQFKAUXs1AnTIyShqaBhEpshLizlPWmmVXAR1iGJUGdIW8giIBzUA9mnYuto1TrSp7LIqarSq6rat6rCq7lTS05aSl0CxH0qygCDRe1ydMPyjWPL/eurrXuroPyLDvnGcQkWwUm61mZi2H6ngkzYqKsuKiRnHZmg7uRtHppmmlLtM3WFZ0WZa1a9g6G0ZnaDl7y4qLITueATMM9YJiHLoXOk5YbpyYZ1HU5DR5lU3DFA07F7zOhgSYtLSimoZhZAqQ5zhppVlujaKyCijAJMQIhTbEBCVl48R8o7gcoFOB2kxSCvUCo4GGEqEZFFvSShpawOCRERcBCqhb2AKDA5RyMAAAiZhuqh37UK0AAAAASUVORK5CYII=","aspectRatio":1.9428571428571428,"src":"/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png","srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/c972b/react.png 340w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/27625/react.png 680w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/b7e46/react.png 732w","sizes":"(max-width: 732px) 100vw, 732px"}}}},"timeToRead":8,"parent":{"__typename":"File","modifiedTime":"2021-05-15T08:14:04.647Z"}}},"pageContext":{"slug":"/2018-07-reactlife/","previous":{"fields":{"slug":"/2018-06-gautm/"},"frontmatter":{"title":"Google analytics UTM設定參數，追蹤facebook廣告、簡訊、EDM","tags":["google_analytics"]}},"next":{"fields":{"slug":"/2018-07-gasession/"},"frontmatter":{"title":"Google Analytics 工作階段介紹、定義","tags":["google_analytics"]}}}},"staticQueryHashes":["1481458783","63159454"]}