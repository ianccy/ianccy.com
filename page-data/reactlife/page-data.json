{"componentChunkName":"component---src-templates-post-tsx","path":"/reactlife/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu"}},"markdownRemark":{"id":"9b142dd4-6739-535e-8a69-94556f8cf751","excerpt":"如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle…","html":"<p>如果在開發上是用 React，最常用到就是一定是處理 state、props，而其中最重要的莫過於是生命週期 lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新 props 觸發處理事件等等。接下來就來介紹 life Cycle，順便了解新版本多的功能，還有未來會移除的功能。</p>\n<h2>React Life Cycle</h2>\n<p>大致上可分類為 Mounting 增加、Updating 更新、Unmounting 移除增加。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"margin: 7vw 0;\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.21212121212122%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVQoz53S227jIBCA4b7/y1XbrpK0tmPHB/CJgeGMDXjVKK3UXO5/x8WnGQEvx3cp5z3GPX6VUjJuI4Te2pYQCgxCCCml+F3O+TiOlx8cQiBkqMoCgEmptFaIWBTlPC/OeW2M4Lyu66IoGYMY4y+sbSg7+FuQYTZGKw5MSQS2ogC2zhJR3kNEpdS+7w8cQtj3XWn/2cnzjdfU1AN81rQZ2I0AWfS1hwWk+rLqF9627XQ6V2WltBuZnsBMoJsB3svxVK+XG+9mMzIDqKXEZ5xS1lo756xzwAWAUEqDUEXHT5f+VIx0lYJzvA9WSj2vfb+5A5WriKqIbiZ7peZUzdcBm9E0syupWUBLFIhSCCGlfODg/TAQQoi11linjXV+c1YGWQB9n9rXpf/j+MWbVWljrFZaGWt+1k6IKJWOu82BZE+yH/T6YdnHJoqoqsN3h2tiECk93iXnnO6Hlxhjfa3bW+e96cj52r7RuRSc0KW6DeeqeWvJZRG19ciQtWPTkOuKywPnnLdti3v0W+hn0o79BEvYN9CcsrGb+n4aVslscAxZR9uWtgufn3/Yf/QP7CqoTj/yjx4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/a805d/react-life.webp 495w,\n/static/56e1ae1a077d66ecc3899de3eec3e5d6/6ec60/react-life.webp 800w\"\n              sizes=\"(max-width: 800px) 100vw, 800px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/b3db0/react-life.png 495w,\n/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png 800w\"\n            sizes=\"(max-width: 800px) 100vw, 800px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/56e1ae1a077d66ecc3899de3eec3e5d6/acfc1/react-life.png\"\n            alt=\"react lifecycle\"\n            title=\"react lifecycle\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\">react lifecycle</figcaption>\n  </figure>\n大推 Dan Abramov 的圖表， <a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\" title=\"React Life Cycle\">網站版 React Life Cycle 網友製</a></p>\n<p>PS.React 官方已經在 2018/03/27 宣告 不推薦使用:\ncomponentWillMount、componentWillReceiveProps、componentWillUpdate 並且 react 16.3 版本以後這些 method 會加上前綴 UNSAFE_，17 版本會丟棄。提醒使用的時候要特別小心。</p>\n<p>另外在看下面的時候可以搭配使用 <a href=\"https://codesandbox.io/s/xp7lk14x4w\" title=\"React Life Cycle\">react life Cycle sample</a>，點開 console.log 查看執行順序，裡面操作主要兩個，一個是父元件更新傳遞的 props，還有元件自己 setState。</p>\n<h2>Mounting</h2>\n<p>Mounting 會在元件被建立時被執行。</p>\n<h4>constructor() :</h4>\n<p>這是 es6 的 class 語法糖，可以說是建構並初始化物件，這邊會繼承 React.Component，假設你元件要使用到 props，就必須這樣寫 super(props)來繼承父類別。這階段簡單說就是開始建立這個物件。如果你沒有要定義 state、或是在這邊綁定 method (另可以選用 arrow function 綁定 method)，就不需要用到 constructor。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// get parents props</span>\n<span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>componentWillMount() -> 17 版將丟棄 :</h4>\n<p>緊接在 constructor 後執行 componentWillMount，提醒只會在初始執行一次，移除後重新建立元件也不會在執行 componentWillMount。另外是唯一會在 server side render 時執行的 life Cycle method，關於 WillMount 最多的討論就是，在這邊擺放 fetch api 是否正確。</p>\n<p>官方表示，因為 server side 會執行一次，client side 也會再多執行一次，造成重複要資料動作。另外在這邊做 async api 處理，是無法暫停 render 動作，你一樣要等 render 完成後，你還是必須等待類似 loading 空畫面跑出來，才能在更新畫面，所以會更推薦在 componentDidMount 做 fetch api。</p>\n<h4>get­Derived­State­From­Props(nextProps, prevState) -> 新增</h4>\n<p>get­Derived­State­From­Props 主要是對比到 componentWillReceiveProps，get­Derived­State­From­Props 帶有兩個參數 nextProps, prevState，更新後的 props，先前的 state，這個 method 會在初始 render 調用，還有父元件重新 render，也會調用到。</p>\n<p>還有當你使用了 get­Derived­State­From­Props，要更新 state 就需要回傳物件，如果不更新就必須回傳 null。</p>\n<p>PS.當你使用 get­Derived­State­From­Props，也同時使用 componentWillMount，WillMount 會不執行，並且 console 會傳出警告，另外就算改用 UNSAFE_componentWillMount 也不會執行。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Initialize state in constructor,</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token literal-property property\">isScrollingDown</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token literal-property property\">lastRow</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// means you can not use \"this.setState\"</span>\n  <span class=\"token comment\">// return will update state</span>\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props<span class=\"token punctuation\">,</span> state</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>currentRow <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>lastRow<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token literal-property property\">isScrollingDown</span><span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>currentRow <span class=\"token operator\">></span> state<span class=\"token punctuation\">.</span>lastRow<span class=\"token punctuation\">,</span>\n        <span class=\"token literal-property property\">lastRow</span><span class=\"token operator\">:</span> props<span class=\"token punctuation\">.</span>currentRow<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// Return null to indicate no change to state.</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nby officical react</code></pre></div>\n<p>官方介紹使用情境: <a href=\"https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\" title=\"get­Derived­State­From­Props example\">get­Derived­State­From­Props example</a></p>\n<p>移動到 Update 部分: <a href=\"#static-getDerivedStateFromProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4>render()</h4>\n<p>執行 setState、更新父元件傳遞的 props，都會執行 render()，假設 shouldComponentUpdate()回傳 false，則是阻止 render 執行。使用 render 必須回傳 react element(JSX、createClass、react 元件)、或 Fragment、Portals(可以綁定 render 到其他 Dom root)、如果不回傳內容則回傳 boolean、或是 null。</p>\n<p><a href=\"https://reactjs.org/docs/portals.html\" title=\"Portals\">Portals</a></p>\n<p>然後使用 render 盡量保持 pure，例如盡量少在這邊額外處理 props 以及 state，在外面處理保持 render 內乾淨。(這點我也沒做到…)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">filterProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> personList <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token punctuation\">{</span>personList<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">elem</span> <span class=\"token operator\">=></span> elem<span class=\"token punctuation\">.</span>age <span class=\"token operator\">></span> <span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n        older than <span class=\"token number\">20</span> <span class=\"token literal-property property\">years</span><span class=\"token operator\">:</span>\n        <span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">filterProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>componentDidMount()</h4>\n<p>componentDidMount 會在 render 執行完成後調用。這應該是最多人用到的生命週期，舉凡綁定 DOM 事件，執行 ajax，多半會在這邊使用。提醒在這邊使用 setState 會迫使 render 執行兩次，盡量在 constructor 內設定好初始 state，避免過多 render 執行。</p>\n<p>另外提醒在這邊綁定 DOM eventListener，記得在 willUnMount 取消綁定 EventListener，如果重新 render 元件會再次執行 DidMount，造成過多的綁定事件。</p>\n<br/>\n## Updating\n主要是在父元件更新傳遞的props，或是元件中使用到setState，會開始整個Update的生命週期。另外setState({xxxx},callback)，則是會在整個週期執行完成才會執行callback。\n<h4>componentWillReceiveProps(nextProps) -> 17 版將丟棄</h4>\n<p>componentWillReceiveProps(nextProps)，會回傳更新過的 props，並且可以使用 setState 來更新 state，提醒在這邊使用 setstate，並不會驅使重跑 componentWillReceiveProps，因為 ReceiveProps 只會在更新傳遞的 props 時被調用。</p>\n<p>react 官方是創建 get­Derived­State­From­Prop 來替代掉 WillReceiveProps，主要明顯差異在於 get­Derived­State­From­Prop 必須使用 static，且會在 Mounting 階段執行，\b\b\b 但是會自動傳遞更新 state，而 componentWillReceiveProps 則是純粹執行，\b 不依靠 return 更新。</p>\n<h4>static getDerivedStateFromProps(nextProps, prevState) -> 新增</h4>\n<p>Updating 階段中，getDerivedStateFromProps 則是在父元件更新傳遞的 props 時調用，提醒一下這時候 this.props state 還會是未更新的。</p>\n<p>移動到 Mounting 部分: <a href=\"#get%C2%ADDerived%C2%ADState%C2%ADFrom%C2%ADProps-nextProps-prevState-gt-%E6%96%B0%E5%A2%9E\" title=\"get­Derived­State­From­Prop\">get­Derived­State­From­Prop</a></p>\n<h4>shouldComponentUpdate(nextProps, nextState)：</h4>\n<p>執行 receive props 後調用，這時候 this.props state 還會是未更新的。主要是判斷元件是否要往下繼續執行 willUpdate、render、componentDidUpdate，如果回傳 false，則會中斷整個更新循環，回傳 true 則是繼續往下執行，默認值為 true。</p>\n<p>一般會使用 shouldComponentUpdate 來優化效能，避免執行沒必要的 render。</p>\n<h4>componentWillUpdate（nextProps, nextState) -> 17 版將丟棄</h4>\n<p>Update 到 render 前最後一個，\b 提醒在這邊使用 setState 的話，會導致重跑回 update 的生命週期，然後在跑到 componentWillUpdate，若沒有設定好判斷，就會再 setState，再重跑回一遍，變成反覆 infinite 執行。</p>\n<h3>render</h3>\n<p>Update 階段中開始處理 react 的畫面架構。提醒在這邊 setState 也同樣會重跑 Update，也同樣不建議在這邊執行 setState，容易產生無限迴圈。</p>\n<p>其餘跟 Mounting 階段一樣，回傳 react element，或是 react 相關的物件。</p>\n<h3>getSnapshotBeforeUpdate(prevProps, prevState) -> 新增</h3>\n<p>能夠抓取 render 到執行渲染畫面更新前，所保持的畫面狀態，然後再傳第一個新值給 componentDidUpdate 當參數使用。</p>\n<h4>componentDidUpdate(prevProps, prevState, snapshot)</h4>\n<p>Updating 階段最後一個執行，在畫面渲染更新後調用，新版本的還多加 getSnapshotBeforeUpdate 傳遞的參數。</p>\n<p>在這邊可以處理 call api 動作，或是 setState，促使重新更新，但提醒記得要判斷執行時機，否則一樣會進入無限迴圈。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevProps</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>name <span class=\"token operator\">!==</span> prevProps<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">updateUser</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n## Unmounting\n移除的時候會執行這個生命週期\n<h4>componentWillUnmount()</h4>\n<p>元件要被移除的時候會執行，可以做清除綁定 eventlistener，或是清除 cookie、local storage 等等，提醒在這邊 setState 是不會重新執行 render。</p>\n<p>以上就是關於 react 新版的生命週期，看過一遍後更能理解，在哪個階段做什麼處理會更適合。</p>\n<h2>元件渲染順序</h2>\n<p>大型開發滿常遇到這個問題，子元件先執行 render 還是父元件先，還有 lifeCycle 在父子元件的調用順序。稍微試跑了一下流程。\n請查看 console <a href=\"https://codesandbox.io/s/5kpvvkqx7k\" title=\"react life Cycle parents child order\">react life Cycle parents child order</a></p>\n<ul>\n<li>\n<p>Mounting\b: 簡單講就是父元件先執行到 render 後，再來開始執行子元件的 Mounting 生命週期，最後執行完子元件的 componentDidMount 後，再回頭執行父元件的 componentDidMount。</p>\n</li>\n<li>\n<p>Updating: 父元件執行到 render 後，換子元件執行直到 getSnapshotBeforeUpdate()，會再回父元件執行 getSnapshotBeforeUpdate()，然後再執行子元件的 componentDidUpdate，再回父元件執行 componentDidUpdate。</p>\n</li>\n<li>\n<p>UnMounting: 父元件先執行 componentWillUnmount，再來是子元件執行。</p>\n</li>\n</ul>\n<p>以上就是關於 react 的新版生命週期，還有父子元件執行的順序。實際研究才發現各階段德每個 method 有許多細節，例如說 mounting 階段，componentWillMount 執行 fetch api，因為他只會在第一次 Mounting 被調用的特性，如果是抓取後續不會更新的資料，其實也是一種選擇，但今天如果你後面還可能會再次 call api，或許 componentDidMount 會更適合使用。</p>\n<p>—以上如果有錯誤，歡迎留言。感謝!—</p>\n<!--- ![react lifecycle](../images/react.png \"react lifecycle\") --->\n","fields":{"readingTime":{"text":"11 min read"}},"frontmatter":{"title":"React Life Cycle 生命週期更新版，父子元件執行順序","date":"July 27, 2018","description":"開發上用到React，而其中最重要的莫過於是生命週期lifeCycle，可以在每個元件渲染的過程，加入需要的處理，例如載入完元件後非同步抓取資料，更新props觸發處理事件等等。接下來介紹一下新版本的life Cycle。","categories":"javascript","tags":["react.js"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/49f3722d7cadbd2be8eefba27f6a5890/b1838/react.png","srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/caad8/react.png 183w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/aef11/react.png 366w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/b1838/react.png 732w","sizes":"(min-width: 732px) 732px, 100vw"},"sources":[{"srcSet":"/static/49f3722d7cadbd2be8eefba27f6a5890/305d6/react.webp 183w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/12464/react.webp 366w,\n/static/49f3722d7cadbd2be8eefba27f6a5890/164a3/react.webp 732w","type":"image/webp","sizes":"(min-width: 732px) 732px, 100vw"}]},"width":1280,"height":657.4863387978141}}},"image":{"publicURL":"/static/49f3722d7cadbd2be8eefba27f6a5890/react.png"}}},"previous":{"fields":{"slug":"/2018-06-gautm/"},"frontmatter":{"title":"Google analytics UTM設定參數，追蹤facebook廣告、簡訊、EDM"}},"next":{"fields":{"slug":"/2018-07-gasession/"},"frontmatter":{"title":"Google Analytics 工作階段介紹、定義"}}},"pageContext":{"id":"9b142dd4-6739-535e-8a69-94556f8cf751","previousPostId":"bafe289c-b127-5e01-8eee-ea2daab96ea8","nextPostId":"e33fef9e-b7c0-596c-af80-68e8bc24e0ef"}},"staticQueryHashes":["3649515864","3761976949","441988385"]}