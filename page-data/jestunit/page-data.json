{"componentChunkName":"component---src-templates-blog-post-js","path":"/jestunit/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"d5411fa6-fe29-5f4a-949d-fc9aa8184985","fields":{"slug":"/2019-09-jestunit/"},"headings":[{"value":"安裝測試工具 Jest","id":"安裝測試工具-jest","depth":2},{"value":"react-test-renderer Snapshot Testing","id":"react-test-renderer-snapshot-testing","depth":2},{"value":"Component Testing @testing-library/react","id":"component-testing-testing-libraryreact","depth":2},{"value":"心得","id":"心得","depth":2}],"excerpt":"Unit Test(單元測試)，針對程式的最小單位，進行測試，最小單位可能是一個 function，或一個 component、class…","html":"<p>Unit Test(單元測試)，針對程式的最小單位，進行測試，最小單位可能是一個 function，或一個 component、class 等等，執行單元測試是為了確保每個功能都能夠正常執行，提早發現並找出問題所在。</p>\n<p>目前正在開發新專案，但又要兼顧維運另個舊專案，舊專案是公司核心產品，常常需要改動需求，因為新專案 deadline 緊迫，不大有時間詳細的測試改動，最近疊加太多功能，導致連動出現滿多 bug，因為這事件，更讓我們重視測試的重要性。</p>\n<!--- ![react unit test](../images/reactunittest.png \"react unit test\") --->\n<p>接下來就來針對 react hooks 做 component testing。</p>\n<h2 id=\"安裝測試工具-jest\" style=\"position:relative;\"><a href=\"#%E5%AE%89%E8%A3%9D%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7-jest\" aria-label=\"安裝測試工具 jest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>安裝測試工具 Jest</h2>\n<p>Jest 是由 facebook 開源的工具，源自於 Jasmine 延伸開發，設定少、輕巧，官方文件非常清楚，提供斷言庫、mocking data 等，Jest 算是我們 test 的 runner，可以再搭配 enzyme、puppeteer 等等執行，讓 test 能更齊全。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">npm install --save-dev jest</code>\n        </deckgo-highlight-code>\n<ul>\n<li>編輯 package.json</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">  &quot;scripts&quot;: {\n    ...\n    &quot;test&quot;: &quot;jest&quot;,\n    ...\n  }</code>\n        </deckgo-highlight-code>\n<p>執行 Jest 會預設抓取 <code>__tests__</code> folder 內 js、ts 檔案，或是 fileName 有 spec、test 的 js ts 檔案 來跑測試， 假設你有用到 babel，或是其他 css 編譯工具，則需要設定 jest config。</p>\n<p>規則預設</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">[&#39;**/__tests__/**/*.[jt]s?(x)&#39;, &#39;**/?(*.)+(spec|test).[jt]s?(x)&#39;];</code>\n        </deckgo-highlight-code>\n<p>官方文件: <a href=\"https://jestjs.io/docs/en/getting-started\" title=\"Jest starter guide\">Jest starter guide</a></p>\n<p>Jest 主要依賴幾個 function 執行測試，describe function 可以讓我們對這一個測試做命名，以便後面執行測試追蹤，test function 則是讓我們定義某個 test case，例如範例，我們用 describe 測試包覆多種狀況來測試，expect 則是讓我們丟入 function 做 return，toBe 就是預期測試結果是否符合預期。</p>\n<p>官方文件: <a href=\"https://jestjs.io/docs/en/using-matchers\" title=\"Jest 斷言方式\">Jest 斷言方式</a></p>\n<ul>\n<li>Jest 使用</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">describe(&#39;Test sum&#39;, () =&gt; {\n    test(&#39;function return 0&#39;, () =&gt; {\n        expect(sum(0)).toBe(0);\n    });\n    test(&#39;function sum 0, 1 return 1&#39;, () =&gt; {\n        expect(sum(0, 1)).toBe(1);\n    });\n});</code>\n        </deckgo-highlight-code>\n<p>目前新專案是純倚賴 Jest 來測試，主要規劃會以 function test 以及 end to end 為主，主要先針對最重要的 function 做不同情境測試。</p>\n<p>安裝完成有遇到 react-script start 會有 jest error，依照提示移除 jest、node_modules、package-lock.json，並重新安裝即可解決。</p>\n<h2 id=\"react-test-renderer-snapshot-testing\" style=\"position:relative;\"><a href=\"#react-test-renderer-snapshot-testing\" aria-label=\"react test renderer snapshot testing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react-test-renderer Snapshot Testing</h2>\n<p>剛好在 react test guide 看到，好奇順便研究一下，react-test-renderer 是 facebook 開發的工具，功能直覺簡單，是用來實現不需要依賴瀏覽器 render component 執行 test，首先會幫你 render compoent，並可讓你執行 toMatchSnapshot 匯出元件 render Snaphot，也可在依照 render component 模擬更新互動，更新後狀態也可匯出 snapshot，另外也可以純取值比較。</p>\n<p>如果你元件經常要更新，可想而知你這份 snapshot testing 會經常需要更新，但如果穩定，就可以直接測試出 component 與資料不同的更新樣貌。</p>\n<p>文件: <a href=\"https://reactjs.org/docs/test-renderer.html#testrenderer\" title=\"react-test-renderer\">react-test-renderer</a></p>\n<p>下面是簡單的元件，主要測試是觸發 <code>&#x3C;span></code> 的 onClick 讓 state count 更新。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function TodoView() {\n    const inputEl = useRef(null);\n    const [todoList, addTodo, deleteToDo] = useTodoList([], inputEl);\n    const [count, setCount] = useState(0);\n\n    return (\n        &lt;div&gt;\n            &lt;span onClick={() =&gt; setCount(count + 1)}&gt;Counter : {count}&lt;/span&gt;\n            ...\n        &lt;/div&gt;\n    );\n}</code>\n        </deckgo-highlight-code>\n<p>下方為實際使用範例，主要邏輯就是使用 create render component，再把元件資料轉格式匯出 snapshot，並可以用 act 來調用 component function，直接拉 props function 用會有 error warning，主要用起來困難點會是在 selector，還是如何整理 snapshot 匯出格式，幫助我們日後測試。</p>\n<p>目前專案尚未導入 snapshot test，因為專案還在不斷改動中，評估 component test 維運成本過高先略過。</p>\n<ul>\n<li>src/<strong>testSnap</strong>/TodoView.test.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\nimport { create, act } from &#39;react-test-renderer&#39;;\nimport TodoView from &#39;/container/TodoView&#39;;\n\ndescribe(&#39;TodoView component&#39;, () =&gt; {\n    test(&#39;it shows the expected text when clicked&#39;, () =&gt; {\n        let component;\n        act(() =&gt; {\n            component = create(&lt;TodoView /&gt;);\n        });\n        let tree = component.toJSON();\n        expect(tree).toMatchSnapshot();\n        const instance = component.root;\n\n        const button = instance.findByType(&#39;span&#39;);\n        act(() =&gt; button.props.onClick());\n        expect(button.props.children.join()).toBe(&#39;Counter : ,1&#39;);\n        expect(button.props.children).toMatchSnapshot();\n    });\n});</code>\n        </deckgo-highlight-code>\n<h2 id=\"component-testing-testing-libraryreact\" style=\"position:relative;\"><a href=\"#component-testing-testing-libraryreact\" aria-label=\"component testing testing libraryreact permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Component Testing @testing-library/react</h2>\n<p>React 官方範例是可以依賴內部 function act 去 render component，並依賴 dispatch event 去觸發事件，但若是複雜，官方更推薦使用 @testing-library/react，這是一套專注於測試 user interactive 的工具，可以讓我們模擬 select component -> click，有別於 enzyme 依賴執行 function trigger 更新 component。</p>\n<p>這套工具是同事推薦的，react testing library 專注的方向符合我們的需要，更能貼近使用者實際的互動。</p>\n<ul>\n<li>React 官方 test note</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">We recommend using React Testing Library which is designed to\nenable and encourage writing tests that use your components\nas the end users do.\n\nAlternatively, Airbnb has released a testing utility called Enzyme,\nwhich makes it easy to assert, manipulate, and traverse your\nReact Components’ output.</code>\n        </deckgo-highlight-code>\n<p>下方為 TypeInInput 的元件，預期當我們 pass text 會 render 出字串，並觸發 onChange event 傳遞 value，再來比較 input 內的 value 是否符合，接下來就來測試這個情境。</p>\n<p>@testing-library/react 主要依賴 render 來 render component，fireEvent 則讓我們可以觸發事件(click、change、dispatch Event)。</p>\n<p>主要流程大致為 render component，並接受返回的 function，各種 selector 都會在這時候取得，目前寫起來最順手是利用 getByTestId 搭配 data-testid，以往再寫 react component，會比較少寫 class or id，利用 tag 或是 string 來做選擇，難度更是麻煩，這些更常會因為需求更新。</p>\n<ul>\n<li>TypeInInput Component</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { useState } from &#39;react&#39;;\nimport { render, fireEvent } from &#39;@testing-library/react&#39;;\n\nfunction TypeInInput({ text }) {\n    const [value, setValue] = useState(&#39;&#39;);\n    const onChangeValue = e =&gt; {\n        setValue(e.target.value);\n    };\n    return (\n        &lt;div&gt;\n            &lt;label&gt;{text}&lt;/label&gt;\n            &lt;input data-testid=&quot;typeIn&quot; value={value} onChange={onChangeValue} /&gt;\n        &lt;/div&gt;\n    );\n}\n\ndescribe(&#39;Test TypeInInput&#39;, () =&gt; {\n    const text = &#39;email&#39;;\n    test(&#39;change event&#39;, () =&gt; {\n        const { getByText } = render(&lt;TypeInInput text={text} /&gt;);\n        const title = getByText(/email/);\n        expect(title.textContent).toEqual(text);\n    });\n    test(&#39;change event&#39;, () =&gt; {\n        const { getByTestId } = render(&lt;TypeInInput text={text} /&gt;);\n        const typeInElem = getByTestId(&#39;typeIn&#39;);\n        const test = &#39;emample@gmail.com&#39;;\n        fireEvent.change(typeInElem, { target: { value: test } });\n        expect(typeInElem.value).toEqual(test);\n    });\n});</code>\n        </deckgo-highlight-code>\n<p>至於比較複雜的 async function api 的操作，記得要修改 babel config 執行非同步，以及安裝 @testing-library/jest-dom 執行 toHaveTextContent，讓斷言能更靈活。</p>\n<ul>\n<li>babel.config.js</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">[\n    &#39;@babel/preset-env&#39;,\n    {\n        targets: {\n            node: &#39;current&#39;\n        }\n    }\n];</code>\n        </deckgo-highlight-code>\n<p>Fetch 接受 url、axios (模擬 api call) 兩個 prop。Component 內用到 state、useCallback、建立 function fetchData，</p>\n<p>Component 預期狀態</p>\n<p>useEffect 會在元件 render 傳入 url 以及 apiCall function，並執行 click element 觸發 fetchData 調用 apiCall 更新 state。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { useState, useCallback } from &#39;react&#39;;\nimport axios from &#39;axios&#39;;\nimport { render, fireEvent, waitForElement } from &#39;@testing-library/react&#39;;\n\nimport &#39;@testing-library/jest-dom/extend-expect&#39;;\n\nfunction Fetch({ url, apiCall }) {\n    const [data, setDate] = useState();\n    const fetchData = useCallback(async () =&gt; {\n        const response = await apiCall.get(url);\n        setDate(response.data);\n    }, [apiCall, url]);\n    return (\n        &lt;div&gt;\n            &lt;button onClick={fetchData}&gt;Fetch&lt;/button&gt;\n            {data ? &lt;span data-testid=&quot;fetch&quot;&gt;{data.test}&lt;/span&gt; : null}\n        &lt;/div&gt;\n    );\n}\n\ntest(&#39;Fetch makes an API call and displays the greeting&#39;, async () =&gt; {\n    const fakeAxios = {\n        get: jest.fn(() =&gt; Promise.resolve({ data: { test: &#39;hello world&#39; } }))\n    };\n    const url = &#39;https://example.com/get-hello-there&#39;;\n    const { getByText, getByTestId } = render(&lt;Fetch url={url} apiCall={fakeAxios} /&gt;);\n    fireEvent.click(getByText(/fetch/i));\n\n    const fetchNode = await waitForElement(() =&gt; getByTestId(&#39;fetch&#39;));\n\n    expect(fetchNode).toHaveTextContent(&#39;hello world&#39;);\n});</code>\n        </deckgo-highlight-code>\n<p>更複雜例子也可以查閱作者在 codesandbox 寫的各種 sample code，</p>\n<p>作者範例: <a href=\"https://codesandbox.io/s/github/kentcdodds/react-testing-library-examples\" title=\"kentcdodds codesandbox\">kentcdodds codesandbox</a></p>\n<h2 id=\"心得\" style=\"position:relative;\"><a href=\"#%E5%BF%83%E5%BE%97\" aria-label=\"心得 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>心得</h2>\n<p>單元測試在我剛寫程式時，認為測試 case 是自己預期的，還主觀的認為沒什麼用，因為開發者所預期的測試一定充滿盲點，沒太大用處。但我在實際寫幾個測試後，發現最大的功用在於程式的 clear，當你在寫某個功能時，能更專注在預期判斷 input output，也有助於你思考 function 架構更清楚。</p>\n<p>你可能會說每次測試都沒抓到真實發生的 bug，這時就要換個角度思考，為什麼測試 case 沒測試到，是不是情境 case 太過簡單、理想，是不是需要再擴展更多 case。</p>\n<p>新專案不幸的重構了大概兩次左右…，還是最重要的資料更新，運氣很好的在改動中有在測試階段發現問題，我大概被抓到兩次問題，當時心想這個 testing case 的時間成本回本了 XDD，不斷讓我佩服 unit test 發揮做用。</p>\n<p>內文這些實際範例，寫起來最卡的部分在環境設定，非同步測試…、編譯錯誤等等，還有熟悉 selector 與斷言方式，不像是 enzyme 有 cherrio 支援類似 jquery 的語法，剩下就是各種使用測試技巧，這個寫更多案例後會更熟悉。後續有 react-testing-library 實際導入專案會再多寫相關內容。</p>\n<p>以上若有錯誤，歡迎留言提醒，</p>\n<p>感謝閱讀。</p>","frontmatter":{"title":"React Unit Test with Jest 單元測試","date":"September 29, 2019","description":"單元測試在我剛寫程式時，認為測試 case 是自己預期的，還主觀的認為沒什麼用。但我在實際寫幾個測試後，能更專注在預期判斷 input output，也有助於你思考 function 架構更清楚。接下來就來針對 react hooks 做 component testing。","categories":"javascript","tags":["react.js","testing"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABf0lEQVQoz3XO6U7CQBQF4Hn/F9DExAUjKhIkMSYSMYgouxQoLbSUdrpAW8oWX+B4p1RBoz++TGc6d85hNd2BUP9HTbdR1ciIJ+zYG3kdclRUjhfVQlmxUBqYYO2Jh/fY9E9dO4DsRegLboSO5aNluMRDc+yiMU6CtW0Q6/EZfutaU/RtGtQ5DlNp5B5LyBfLyD4UUWxIkJ0AHdODRPc6JgUTUUwEsQE1+KI4Ybyq1EabLaG6c9wWSsjcFZDO3yP/+IyarEPzVxjQozKF9rmwK8JG3hw7IfTZAi3VQLWr4E1S0DMcVHsq2sMJZGpV6choDHR06VylAoJCjytJKTaeRRAMok/n4NEGpXobJ+kMUtdZPFWbKLckHByf4fTqBuc3OZxcZnCUusDQ8eNZjcoIIzcEM/0FTH8Ja49JLSeEB6t4z8NVfMeYRrACWmlYGhoQs5OkTIwKMR6saYAEO3a4ie3/s8P195n4dqOPJHD1owhzojX+NP+feFC03ob8LPQJvTGAvR7l8SsAAAAASUVORK5CYII=","aspectRatio":2.193548387096774,"src":"/static/7956ce03fba51cee80d476032b4bd3a6/ee604/reactunittest.png","srcSet":"/static/7956ce03fba51cee80d476032b4bd3a6/c972b/reactunittest.png 340w,\n/static/7956ce03fba51cee80d476032b4bd3a6/27625/reactunittest.png 680w,\n/static/7956ce03fba51cee80d476032b4bd3a6/ee604/reactunittest.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":7,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.154Z"}}},"pageContext":{"slug":"/2019-09-jestunit/","previous":{"fields":{"slug":"/2019-08-gacrossdomain/"},"frontmatter":{"title":"GA跨網域追蹤 google analytics cross-domain tracking","tags":["google_analytics"]}},"next":{"fields":{"slug":"/2019-11-reduxdispatch/"},"frontmatter":{"title":"Redux multiple dispatch，batch redux-thunk","tags":["react.js"]}}}},"staticQueryHashes":["1481458783","63159454"]}