{"componentChunkName":"component---src-templates-blog-post-js","path":"/closure/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"6f1a16aa-0136-532e-8156-1dc356e0725b","fields":{"slug":"/2020-06-closure/"},"headings":[{"value":"Closure 封裝變數","id":"closure-封裝變數","depth":2},{"value":"JavaScript 作用域","id":"javascript-作用域","depth":2},{"value":"setTimeout 解法","id":"settimeout-解法","depth":3},{"value":"心得","id":"心得","depth":2}],"excerpt":"JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。 Clousre 在 MDN 上解釋為 這個解釋是我看過比較簡單直白的。 而我自己對 closure 白話解釋的話，就是利用 return…","html":"<p>JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。</p>\n<!--- ![javascript closure](../images/closure.png \"javascript closure\") --->\n<p>Clousre 在 MDN 上解釋為</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">A closure is the combination of a function bundled together (enclosed)\nwith references to its surrounding state (the lexical environment).</code>\n        </deckgo-highlight-code>\n<p>這個解釋是我看過比較簡單直白的。</p>\n<p>而我自己對 closure 白話解釋的話，就是利用 return 回傳值，並且做一個作用域環境封裝。</p>\n<h2 id=\"closure-封裝變數\" style=\"position:relative;\"><a href=\"#closure-%E5%B0%81%E8%A3%9D%E8%AE%8A%E6%95%B8\" aria-label=\"closure 封裝變數 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Closure 封裝變數</h2>\n<p>以下我建立一個變數 a，是一個 object value 是 { name: ‘ian’}，function getValueA 則會回傳 a，javascript 特性，會在 function 建立時，就以同層尋找變數，找不到就一層一層往外。接下來建立變數 assignA 賦予 getValueA() 回傳值。</p>\n<p>嘗試 log 出來後，會發現第一次會是 {name: “ian”}，但是接下來重新賦予 a 的值，神奇的事發生了，發現 assignA 的值並沒有被改變。但嘗試直接 log 回傳 getValueA() 會發現，a 是有成功被改變了。</p>\n<ul>\n<li>封裝 lexical environment ( 作用域環境 )</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">var a = { name: &#39;ian&#39; };\nfunction getValueA() {\n    return a;\n}\nvar assignA = getValueA();\nconsole.log(assignA); // {name: &quot;ian&quot;}\n\na = 2;\nconsole.log(assignA); // {name: &quot;ian&quot;}\nconsole.log(getValueA()); // 2</code>\n        </deckgo-highlight-code>\n<p>這是因為 closure 幫我們做封裝記憶體，javascript 的記憶體管理機制，幫我們把第一次 return a 時，這個 { name: ‘ian’ }，封裝起來避免被記憶體回收，假設要回收 { name: ‘ian’ } 的方法就是讓 assignA 指向新的參考。</p>\n<ul>\n<li>javascript 記憶體回收</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">「沒有其他任何物件參考它」。如果一個物件不在被任何物件參考，它將被視為可回收記憶體的垃圾。</code>\n        </deckgo-highlight-code>\n<p>MDN: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management\" title=\"記憶體生命週期\">記憶體生命週期</a></p>\n<h2 id=\"javascript-作用域\" style=\"position:relative;\"><a href=\"#javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F\" aria-label=\"javascript 作用域 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaScript 作用域</h2>\n<p>下面的這個問題，相信大家面試的時候，都被問到爛了，聽到問題是 forLoop 跟 setTimeout 開頭都快可以直接反射背出答案 X Ｄ。</p>\n<ul>\n<li>經典 (<del>面試</del>) 問題</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">for (var i = 0; i &lt; 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 0);\n}\n// 3\n// 3\n// 3</code>\n        </deckgo-highlight-code>\n<p>這問題又與 javascript event loop 有關，setTimeout 是 web API，在 javascript 執行緒時，碰到 setTimeout 會被特別放到另一個 stack，等到最後才會來執行，邏輯上就是 i 已經被重新更新到 3 了，但是我才要來開始 log i，那結果當然是 3 出現三次。</p>\n<p>MDN: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/EventLoop\" title=\"Event Loop\">Event Loop</a></p>\n<h3 id=\"settimeout-解法\" style=\"position:relative;\"><a href=\"#settimeout-%E8%A7%A3%E6%B3%95\" aria-label=\"settimeout 解法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>setTimeout 解法</h3>\n<p>還是簡單講一下，其中簡單的方法是 var 改用 let，讓每次 let 的作用域被包覆所以記憶起來。另一個就是利用記憶體封裝概念 ，同樣原理也與 let 差不多，利用 function logI(i) 傳入變數，來讓 i 當下的值被封裝。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">for (var i = 0; i &lt; 3; i++) {\n    function logI(i) {\n        setTimeout(function() {\n            console.log(i);\n        }, 0);\n    }\n    logI(i);\n}\n// 0\n// 1\n// 2</code>\n        </deckgo-highlight-code>\n<p>如果你將 logI function 的 argument 拿掉，又會出現三次的 3，因為沒有封裝變數 i。</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">...\n    function logI() {\n        setTimeout(function() {\n            console.log(i)\n        }, 0);\n    }\n    logI();\n...\n// 3\n// 3\n// 3</code>\n        </deckgo-highlight-code>\n<h2 id=\"心得\" style=\"position:relative;\"><a href=\"#%E5%BF%83%E5%BE%97\" aria-label=\"心得 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>心得</h2>\n<p>稍微整理一下最近面試常會問的問題，順便整理一下自己對 closure 基本觀念。在找 setTimeout forLoop 除了 let、立即函示外的解法，才找到 function pass argument，也發現自己也不夠了解 function argument 對於 memory 機制這部分。</p>\n<p>雖然說 react 開發上，比較少會因為 closure 踩到雷，但相信<code>每多懂一點，未來雷就少踩一點</code>。</p>\n<p>感謝閱讀，有錯誤或意見歡迎留言。</p>","frontmatter":{"title":"JavaScript Closure 你一定有用過的閉包","date":"June 27, 2020","description":"JavsScript 的 closure (閉包) 是什麼？ 假設你有在寫 javascript 的話，你可能每天都在用，但你只是沒特別查覺而已。","categories":"javascript","tags":["javascript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAARlAAAEZQAGA43XUAAABwklEQVQoz01R227TQBD1zyLxihA/0apIpVRCfeGhKqDED73QIBKSkASUuLk1SZX4bu863pudVEg0EartMl4HiaOzo9Guz8yZseLajud5OAhnN50fF+/73fZo0LctK4CrZUgIMMdyGWKEQkJDSgmlxYPiOq5jmVpVrZ0e1M8OauWTRvXLYj5fwuc74U6MECL/QYptxzaMZum4/vGwqb5rq8e1y5JhWATq52AAiJDlRiiDs+scgtiyfM/XJ4Nvp3ut0lEU4u3vhyRJ0zRLkwySx8e0SLL06WGzlW4oKHMxQoFj6p7j3P6savWrOL7HmOCA+gg6MUIFIQIHhPE4JGJ9/4tzVliCGkq79KZVUU1dxwhTJkDZ00a9m3F/OOsPp6Pbue3iwWgGhBvGRBQJOUVO5fr18/PDV91mFfuIhHS7+VOYhAg+wXySZKlM0uxps9kWi5Akyte3L672n32//IB9/65zsehWJloH4yCOV8AVcLUGxqs1Z1wImILKXcqZPx+9bJ6fWYbp6VNN3e+V9yqfTgzT4nI4BvEfAoyL5cv9y5kX0zH8ate2zLvxpKFOGuVhtxXArnLwvJeIgJxHspTgEoX+L7rxBR444xreAAAAAElFTkSuQmCC","aspectRatio":2.0481927710843375,"src":"/static/d823d2c008518badcd4d3c8af9842dc0/40a76/closure.png","srcSet":"/static/d823d2c008518badcd4d3c8af9842dc0/c972b/closure.png 340w,\n/static/d823d2c008518badcd4d3c8af9842dc0/27625/closure.png 680w,\n/static/d823d2c008518badcd4d3c8af9842dc0/40a76/closure.png 1360w,\n/static/d823d2c008518badcd4d3c8af9842dc0/3e40c/closure.png 1719w","sizes":"(max-width: 1360px) 100vw, 1360px"}}}},"timeToRead":3,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.157Z"}}},"pageContext":{"slug":"/2020-06-closure/","previous":{"fields":{"slug":"/2020-04-immutable/"},"frontmatter":{"title":"Immutable 對於 React 重要性","tags":["javascript","react.js"]}},"next":{"fields":{"slug":"/2020-12-thirtyyearsold/"},"frontmatter":{"title":"30 歲的我","tags":[null]}}}},"staticQueryHashes":["1481458783","63159454"]}