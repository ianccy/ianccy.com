{"componentChunkName":"component---src-templates-blog-post-js","path":"/promise/","result":{"data":{"site":{"siteMetadata":{"title":"Ian Chu","author":"Ian Chu","siteUrl":"https://ianccy.com","social":{"facebook":"chu1228"}}},"markdownRemark":{"id":"02634784-99cd-5901-b6eb-351ac8b269f0","fields":{"slug":"/2019-02-promise/"},"headings":[{"value":"簡易的 Promise","id":"簡易的-promise","depth":2},{"value":"Promise 解決 callback hell","id":"promise-解決-callback-hell","depth":2},{"value":"實現 promise","id":"實現-promise","depth":2}],"excerpt":"Javascript 在 ES6 新增了大量非常實用的功能，其中重要一項就是 Promsie，讓我們可以很直覺的處理非同步，在以前如果我們需要同時發出多個非同步請求，就必須在每次調用 function 時，一起在參數帶回 callback 的 function，重複了幾次就變成了波動拳。 接下來會用 promise…","html":"<p>Javascript 在 ES6 新增了大量非常實用的功能，其中重要一項就是 Promsie，讓我們可以很直覺的處理非同步，在以前如果我們需要同時發出多個非同步請求，就必須在每次調用 function 時，一起在參數帶回 callback 的 function，重複了幾次就變成了波動拳。</p>\n<p>接下來會用 promise 處理 callback hell，還有建立一個簡易的 promise，幫助我們理解 promise。</p>\n<p>\n  <figure class=\"gatsby-resp-image-figure\" style=\"margin: 7vw 0;\">\n  \n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/45d93443ae8910c4adb84870e715d286/acfc1/callbackhell.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 51.717171717171716%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABeElEQVQoz6WSy3KCMBSG2dldF1WRVqejJAEkghcE4wV7HZ+Gjg50r30TfRh9K/8m0Z0dF3bxzZmTcL5zkmBk2RfuH+pHvytAXQbmN+HwFniPoh0QeIGtaYdErtuoWY+olKuoVk1UKlWNJddKpTtkWQajKIpjo/GMeLI4Tl4WENMRxmmE2VuC+ecI6XuC6Wus8/QjgUhjeG0fruPCdT2N73PU6w0UxTeMPC9gmqb8iCMcpBiKOXpRF1ESIhp1MZr1MZQxHvfk3invRiEIYaCEglIGR8prNQt5nithrhPHceB4AQbJHMNkLONZMO1rmWqgxKpJMumBBxzEvip0waQ04B44D+B3OuiEvoxtvacKKTvBzugpKb0UmqYFzzsV2rKrbZMzVEPI3yiZkl4ILetJX6yagjHnAj3dFdTDqJdW72GsViv5C9R0x2azdROqtlyuYLlcwdhsfuSddSCEQBwnNyHEWJ9wvV7D2O/32G632O12/0I5DocDfgEl3lTPHAPGaQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <picture>\n        <source\n          srcset=\"/static/45d93443ae8910c4adb84870e715d286/a805d/callbackhell.webp 495w,\n/static/45d93443ae8910c4adb84870e715d286/6ec60/callbackhell.webp 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/45d93443ae8910c4adb84870e715d286/b3db0/callbackhell.png 495w,\n/static/45d93443ae8910c4adb84870e715d286/acfc1/callbackhell.png 800w\"\n          sizes=\"(max-width: 800px) 100vw, 800px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n          src=\"/static/45d93443ae8910c4adb84870e715d286/acfc1/callbackhell.png\"\n          alt=\"javascript callback hell\"\n          title=\"javascript callback hell\"\n          src=\"/static/45d93443ae8910c4adb84870e715d286/acfc1/callbackhell.png\"\n        />\n      </picture>\n      </span>\n  </span>\n  \n  </a>\n    \n  <figcaption class=\"gatsby-resp-image-figcaption\">javascript callback hell</figcaption>\n  </figure>\n      </p>\n<h2 id=\"簡易的-promise\" style=\"position:relative;\"><a href=\"#%E7%B0%A1%E6%98%93%E7%9A%84-promise\" aria-label=\"簡易的 promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>簡易的 Promise</h2>\n<p>複雜專案可能會出現的波動拳，這畫面我真實有看過…，假設換成用 promise 的話，就可以很輕鬆直覺處理掉，首先我們先建立一個簡單的 ajax function sample code，下面會用 es6 來寫，希望能在整個流程中，讓你了解 es6 的方便。</p>\n<p>宣告一個 getData arrow function，裡面包含 XMLHttpRequest，我們監聽 onreadystatechange，當整個成功取得資料，就調用 resolve 來進行 callback 把資料放進 resolve function 傳遞，當取得資料失敗就調用 reject function 來傳遞資料。</p>\n<p>當我們 new 一個 promise 的同時，我們 callback function 是帶入 function(resolve, reject){resolve or reject}，讓內部 promise function 被我們用 resolve 或是 reject 調用。</p>\n<ul>\n<li>promise 三種狀態</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">擱置（pending）：初始狀態，不是 fulfilled 與 rejected。\n實現（fulfilled）：表示操作成功地完成。\n拒絕（rejected）：表示操作失敗了。</code>\n        </deckgo-highlight-code>\n<p>promise 會等待佇列 pending 狀態，等到被 resolve 觸發 fulfilled，就會開始回調 then，或是被 reject 觸發 catch。</p>\n<p>then 以及 catch 都會回傳一個 promise，也就是說可以<code class=\"language-text\">.then(()=&gt;{}).then(()=&gt;{}).then(()=&gt;{})</code>除非有錯誤產生，否則會往下調用下去。<code class=\"language-text\">.catch(()=&gt;{}).catch(()=&gt;{}).catch(()=&gt;{})</code>則是當 javascript 有錯誤發生，會開始向下 catch，直到沒錯誤為止才會調用 catch function，同時因為沒錯誤所以會停住。</p>\n<ul>\n<li>非同步 function 範例</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// declare arrow function return Promise\n// ** new Promise to inherit Promise instance **\nconst getData = url =&gt;\n    new Promise((resolve, reject) =&gt; {\n        // create http request\n        const xhttp = new XMLHttpRequest();\n        xhttp.onreadystatechange = () =&gt; {\n            console.log(xhttp.readyState);\n            if (xhttp.readyState === 4) {\n                if (xhttp.status === 200) {\n                    // resolve will trigger Promise then callback\n                    console.log(JSON.parse(xhttp.response));\n                    resolve(JSON.parse(xhttp.response));\n                } else {\n                    // reject will trigger Promise catch callback\n                    reject(xhttp.statusText);\n                }\n            }\n        };\n        xhttp.open(&#39;GET&#39;, url, true);\n        xhttp.send();\n    });\n\ngetData(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;)\n    .then(res =&gt; {\n        // destructuring object\n        const { id, title, completed } = res;\n        const html = `&lt;div class=&quot;item&quot;&gt;\n                    &lt;p&gt;Id: ${id}&lt;/p&gt;\n                    &lt;div&gt;Title: ${title}&lt;/div&gt;\n                    &lt;div&gt;Completed: ${completed}&lt;/div&gt;\n                  &lt;/div&gt;`;\n        const newNode = document.createElement(&#39;div&#39;);\n        newNode.innerHTML = html;\n        document.querySelector(&#39;#list&#39;).appendChild(newNode);\n    })\n    // it will run when promise Reject or\n    // in then function appear javascript error\n    .catch(res =&gt; {\n        console.log(res);\n        alert(`Something Error ,because ${res}`);\n    });</code>\n        </deckgo-highlight-code>\n<iframe src=\"//codepen.io/chu1228/embed/yZrVKW/?height=400&theme-id=0&default-tab=js\" width=\"100%\" height=\"400\"></iframe>\n<p><a href=\"https://codepen.io/chu1228/pen/yZrVKW?editors=1111\" title=\"codepen promise demo\">codepen promise demo</a></p>\n<h2 id=\"promise-解決-callback-hell\" style=\"position:relative;\"><a href=\"#promise-%E8%A7%A3%E6%B1%BA-callback-hell\" aria-label=\"promise 解決 callback hell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise 解決 callback hell</h2>\n<p>那如果我們要繼續拉第二筆資料 /todos/2，這時候就能展現 promise 方便了，當拉完資料後，再回傳一個 promise，再用 then catch 去接受回傳值，反覆下去延伸。</p>\n<p>這樣的寫法優點是比起以往依賴 callback 更直覺，另外每次都分同步取資料都可能會失敗。也很容易針對每個段點做不同的錯誤處理。</p>\n<ul>\n<li>add more callback</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">...\ngetData(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;)\n  .then(res =&gt; {\n    appendItem(res);\n    // return getData promise\n    return getData(&#39;https://jsonplaceholder.typicode.com/todos/2&#39;)\n    }\n  )\n  .catch(res =&gt; {\n    console.log(&#39;top&#39;, res);\n  })\n  // it will start next promise then catch\n  .then(res =&gt; {\n    appendItem(res);\n    return getData(&#39;https://jsonplaceholder.typicode.com/todos/3&#39;)\n    }\n  ).catch(res =&gt; {\n    console.log(&#39;middle&#39;, res);\n  })\n  .then(res =&gt; {\n    appendItem(res);\n    }\n  ).catch(res =&gt; {\n    console.log(&#39;bottom&#39;, res);\n  })\n\n// append html function\nconst appendItem = (res) =&gt; {\n    // prevent get null or undefined trigger .catch\n    if (!res) {\n      return;\n    }\n    const { id, title, completed } = res;\n    const html = `&lt;div class=&quot;item&quot;&gt;\n                    &lt;div&gt;Id: ${id}&lt;/div&gt;\n                    &lt;div&gt;Title: ${title}&lt;/div&gt;\n                    &lt;div&gt;Completed: ${completed}&lt;/div&gt;\n                  &lt;/div&gt;`;\n    const newNode = document.createElement(&#39;div&#39;);\n    newNode.innerHTML = html;\n    document.querySelector(&#39;#list&#39;).appendChild(newNode);\n}</code>\n        </deckgo-highlight-code>\n<iframe src=\"//codepen.io/chu1228/embed/yZrMRE/?height=409&theme-id=0&default-tab=js\" width=\"100%\" height=\"410\"></iframe>\n<p><a href=\"https://codepen.io/chu1228/pen/yZrMRE?editors=1111\" title=\"codepen promise demo\">codepen promise demo</a></p>\n<h2 id=\"實現-promise\" style=\"position:relative;\"><a href=\"#%E5%AF%A6%E7%8F%BE-promise\" aria-label=\"實現 promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>實現 promise</h2>\n<p>promise 就像是個魔術，直到 es6 以前都很難處理好分同步處理，我們來試著做一個只單純帶有 then catch 簡易的 promise，來幫助我們更了解 promise。</p>\n<p>先來解讀一下 promise，他是依賴 resolve、reject function 調用的，直接 <code class=\"language-text\">new Promise(()=&gt;{})</code>，可以看到 promise 內部的狀態，有 status、value、then、catch、finally，這邊就先不理會 finally。</p>\n<ul>\n<li>Promise native prototype</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">Promise {&lt;pending&gt;}\n  __proto__: Promise\n  catch: ƒ catch()\n  constructor: ƒ Promise()\n  finally: ƒ finally()\n  then: ƒ then()\n  Symbol(Symbol.toStringTag): &quot;Promise&quot;\n  __proto__: Object\n  [[PromiseStatus]]: &quot;pending&quot;\n  [[PromiseValue]]: undefined</code>\n        </deckgo-highlight-code>\n<p>首先先用 es6 class 建立一個 promise，依照 promise 內部 code，我們也建立內部的變數 status 以及 value，status 是讓我們判斷 pending 或是 fullfill reject 狀態，value 則是用來接帶進來的值。</p>\n<p>這邊比較容易看不懂的是 constructor(callback)，這個 callback 指的是 new Promise( <code class=\"language-text\">(res,rej)=&gt;{ res(&#39;Hello&#39;)}</code> )，簡單講就是你帶進來的 function。我們在使用 promise 會用到兩個 function，reslove 以及 reject，我們也依樣畫葫蘆，依樣命名一個 resolve、reject，依照(resolve,reject)順序帶入 callback，帶進來讓使用者可以調用到。當我們在外部使用第一個 function，就會調用到內部的 reslove，如果是第二個的話則是調用到內部的 reject。</p>\n<p>距離實際的 promise 還缺少了 then、catch，接下來再繼續實作。</p>\n<ul>\n<li>build promise</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">class promise {\n    constructor(callback) {\n        // promise status\n        this.status = &#39;pending&#39;;\n        // create variable to store resolve or reject value\n        this.value;\n        // resolve is not outside resolve\n        // it is use to pass callback function first function\n\n        const resolve = res =&gt; {\n            if (this.status === &#39;pending&#39;) {\n                this.status = &#39;fullfilled&#39;;\n                this.value = res;\n            }\n        };\n\n        // reject is not outside reject\n        // it is use to pass callback function second function\n        const reject = res =&gt; {\n            if (this.status !== &#39;pending&#39;) {\n                this.status = &#39;rejected&#39;;\n                this.value = res;\n            }\n        };\n\n        // it&#39;s keypoint to call reslove or reject function\n        // reslove or reject just assign status and value\n        try {\n            // this resolve is upper resolve function\n            callback(resolve, reject);\n        } catch (err) {\n            reject(err);\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>加上 then catch 接受回傳值</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">...\n  // then will let user call to check status\n  then = (success, failed) =&gt; {\n      console.log(`then`)\n      if(this.status === &#39;fulfilled&#39;){\n          return success(this.value);\n      }\n      if(this.status === &#39;rejected&#39;){\n          return failed(this.value);\n      }\n  }\n  // it will call then function and callback second callback function\n  catch = cb =&gt; {\n      this.then(null,cb);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://codepen.io/chu1228/pen/pGmLez?editors=0011\" title=\"codepen promise build\">codepen promise build</a></p>\n<p>到這裡只是很簡單的 promise 大致上執行邏輯而已，方便我們更好理解 promise 原理，要完整實現還有很多細節要處理，例如說要 then 或是 catch 要 return promise，還有 all race finally 沒有寫上去。你可以看一下更多完整功能要怎實現出來。</p>\n<p><a href=\"https://gist.github.com/vkarpov15/169d61f210c3420accf96f2081ad716d\" title=\"vkarpov15/promise.js\">vkarpov15/promise.js</a></p>\n<p>雖然每次用 promise 都很理所當然，規則已經既定是如此，但如果每次使用都能了解背後原理，能夠以不同角度來看待，我自己覺得對我來說，幫助都很大，最近正在無盡的的優化網頁效能，無限感慨中…。</p>\n<p>如果有錯誤歡迎留言，感謝閱讀。</p>","frontmatter":{"title":"Javascript Promise example 簡易實作模擬","date":"February 18, 2019","description":"接下來會用 promise 處理 callback hell，還有建立一個簡易的 promise，幫助我們理解promise。","categories":"javascript","tags":["javascript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABeElEQVQoz6WSy3KCMBSG2dldF1WRVqejJAEkghcE4wV7HZ+Gjg50r30TfRh9K/8m0Z0dF3bxzZmTcL5zkmBk2RfuH+pHvytAXQbmN+HwFniPoh0QeIGtaYdErtuoWY+olKuoVk1UKlWNJddKpTtkWQajKIpjo/GMeLI4Tl4WENMRxmmE2VuC+ecI6XuC6Wus8/QjgUhjeG0fruPCdT2N73PU6w0UxTeMPC9gmqb8iCMcpBiKOXpRF1ESIhp1MZr1MZQxHvfk3invRiEIYaCEglIGR8prNQt5nithrhPHceB4AQbJHMNkLONZMO1rmWqgxKpJMumBBxzEvip0waQ04B44D+B3OuiEvoxtvacKKTvBzugpKb0UmqYFzzsV2rKrbZMzVEPI3yiZkl4ILetJX6yagjHnAj3dFdTDqJdW72GsViv5C9R0x2azdROqtlyuYLlcwdhsfuSddSCEQBwnNyHEWJ9wvV7D2O/32G632O12/0I5DocDfgEl3lTPHAPGaQAAAABJRU5ErkJggg==","aspectRatio":1.9318181818181819,"src":"/static/45d93443ae8910c4adb84870e715d286/ee604/callbackhell.png","srcSet":"/static/45d93443ae8910c4adb84870e715d286/c972b/callbackhell.png 340w,\n/static/45d93443ae8910c4adb84870e715d286/27625/callbackhell.png 680w,\n/static/45d93443ae8910c4adb84870e715d286/ee604/callbackhell.png 800w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"timeToRead":6,"parent":{"__typename":"File","modifiedTime":"2021-05-16T08:19:40.148Z"}}},"pageContext":{"slug":"/2019-02-promise/","previous":{"fields":{"slug":"/2019-01-reactssr/"},"frontmatter":{"title":"React Server-side rendering SEO處理","tags":["react.js","seo"]}},"next":{"fields":{"slug":"/2019-02-keywordselect/"},"frontmatter":{"title":"SEO關鍵字分析選擇，優化工具介紹","tags":["seo"]}}}},"staticQueryHashes":["1481458783","63159454"]}